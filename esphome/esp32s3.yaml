esphome:
  name: smarthome-esp32s3
  friendly_name: "Edge Compute Node ESP32-S3 (Node A)"

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf
    sdkconfig_options:
      # ECDSA P-256 for certificate signatures
      CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: "y"
      CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED: "y"
      CONFIG_MBEDTLS_ECDSA_DETERMINISTIC: "y"
      # X25519 for key exchange
      CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: "y"
      CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED: "y"
      # TLS 1.3 support
      CONFIG_MBEDTLS_SSL_PROTO_TLS1_3: "y"

ota:
  - platform: esphome
    password: !secret ota_password

api:
  encryption:
    key: !secret api_key_esp32s3

wifi:
  # 全局设置
  fast_connect: true
  
  # 定义多个网络列表
  networks:
    # --- 主网络 (优先连接) ---
    - ssid: !secret wifi_ssid_main
      password: !secret wifi_password_main
      priority: 20  # 数字越大，优先级越高

    # --- 备用网络 (主网络连不上时使用) ---
    - ssid: !secret wifi_ssid_backup
      password: !secret wifi_password_backup
      priority: 10  # 优先级较低

  # 可选：如果两个都连不上，开启热点(AP)模式方便急救
  ap:
    ssid: "ESP32-S3-AP"
    password: !secret wifi_ssid_ap_password

mqtt:
  broker: !secret mqtt_broker
  port: !secret mqtt_port
  certificate_authority: !secret mqtt_ca_cert
  client_certificate: !secret mqtt_client_cert
  client_certificate_key: !secret mqtt_client_key

logger:
  hardware_uart: USB_CDC

globals:
  - id: fall_detected_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

i2c:
  sda: GPIO5
  scl: GPIO4
  scan: true
  id: bus_a

sensor:
  # Network diagnostics
  - platform: wifi_signal
    name: "WiFi RSSI"
    id: wifi_rssi
    unit_of_measurement: "dBm"
    update_interval: 10s

  - platform: uptime
    name: "System Uptime"
    unit_of_measurement: "s"

  # MPU6050 6-axis IMU
  # Calibration: zero-offset compensation from stationary samples
  # Ref: IEEE Std 528-2019
  - platform: mpu6050
    i2c_id: bus_a
    address: 0x68
    accel_x:
      name: "Acceleration X"
      id: acc_x
      accuracy_decimals: 3
      filters:
        - offset: -0.877
        - throttle: 0.3s
    accel_y:
      name: "Acceleration Y"
      id: acc_y
      accuracy_decimals: 3
      filters:
        - offset: -0.145
        - throttle: 0.3s
    accel_z:
      name: "Acceleration Z"
      id: acc_z
      accuracy_decimals: 3
      filters:
        - offset: -0.564
        - throttle: 0.3s
    gyro_x:
      name: "Angular Velocity X"
      id: gyro_x
      accuracy_decimals: 2
      filters:
        - offset: 2.53
        - throttle: 0.3s
    gyro_y:
      name: "Angular Velocity Y"
      id: gyro_y
      accuracy_decimals: 2
      filters:
        - offset: -2.68
        - throttle: 0.3s
    gyro_z:
      name: "Angular Velocity Z"
      id: gyro_z
      accuracy_decimals: 2
      filters:
        - offset: 2.44
        - throttle: 0.3s
    update_interval: 0.1s

  # BMP180 environmental sensor
  - platform: bmp085
    i2c_id: bus_a
    address: 0x77
    temperature: { name: "Indoor Temperature", accuracy_decimals: 1 }
    pressure: { name: "Indoor Pressure", accuracy_decimals: 2 }
    update_interval: 5s

  # Acoustic ADC sampling
  - platform: adc
    pin: GPIO6
    name: "Acoustic ADC Voltage"
    id: sound_adc
    update_interval: 0.2s
    attenuation: 0db
    accuracy_decimals: 4
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 2

  # Resultant acceleration magnitude (G-force)
  - platform: template
    name: "Resultant G-Force"
    unit_of_measurement: "G"
    accuracy_decimals: 3
    update_interval: 0.1s
    filters:
      - throttle: 0.3s
    lambda: |-
      float ax = id(acc_x).state;
      float ay = id(acc_y).state;
      float az = id(acc_z).state;
      if (isnan(ax) || (ax==0 && ay==0 && az==0)) return 0.0;
      return sqrt(ax*ax + ay*ay + az*az) / 9.80665;

  # Dynamic vibration component
  - platform: template
    name: "Dynamic Vibration Component"
    unit_of_measurement: "G"
    accuracy_decimals: 3
    update_interval: 0.1s
    filters:
      - throttle: 0.3s
    lambda: |-
      float ax = id(acc_x).state;
      float ay = id(acc_y).state;
      float az = id(acc_z).state;
      if (isnan(ax)) return 0.0;
      float mag = sqrt(ax*ax + ay*ay + az*az) / 9.80665;
      float dev = fabs(mag - 1.0);
      return (dev < 0.02) ? 0.0 : dev;

  # Angular velocity magnitude
  # Ref: Huynh et al., J. Sensors, vol. 2015, Art. no. 452078
  - platform: template
    name: "Angular Velocity Magnitude"
    unit_of_measurement: "deg/s"
    accuracy_decimals: 2
    update_interval: 0.1s
    id: omega_mag
    filters:
      - throttle: 0.3s
    lambda: |-
      float wx = id(gyro_x).state;
      float wy = id(gyro_y).state;
      float wz = id(gyro_z).state;
      if (isnan(wx)) return 0.0;
      return sqrt(wx*wx + wy*wy + wz*wz);

binary_sensor:
  # Fall detection using accelerometer-gyroscope fusion
  # Ref: Huynh et al., J. Sensors, vol. 2015, Art. no. 452078
  # Thresholds: UFT_acc = 2.4 G, UFT_gyro = 240 deg/s
  # Reported sensitivity: 96.3%, specificity: 96.2%
  - platform: template
    name: "Fall Detection Alert"
    device_class: safety
    id: fall_alert
    lambda: |-
      const float UFT_ACC = 2.4;
      const float UFT_GYRO = 240.0;
      const unsigned long HOLD_MS = 5000;
      
      float ax = id(acc_x).state;
      float ay = id(acc_y).state;
      float az = id(acc_z).state;
      if (isnan(ax)) return id(fall_alert).state;
      float smv = sqrt(ax*ax + ay*ay + az*az) / 9.80665;
      float omega = id(omega_mag).state;
      unsigned long now = millis();
      
      if ((smv > UFT_ACC) && (omega > UFT_GYRO)) {
        id(fall_detected_time) = now;
        return true;
      }
      
      if (id(fall_detected_time) > 0 && (now - id(fall_detected_time)) < HOLD_MS) {
        return true;
      }
      
      return false;

  # Acoustic event detection
  - platform: template
    name: "Acoustic Peak Event"
    device_class: sound
    lambda: |-
      return (id(sound_adc).state > 0.6);
