\chapter{Theoretical Background}
\label{ch:background}

This chapter provides the theoretical foundation for understanding smart home systems, communication protocols, and security mechanisms employed in this thesis.

% ============================================================================
% 2.1 Smart Home Systems Overview
% ============================================================================
\section{Smart Home Systems Overview}
\label{sec:smarthome-overview}

A smart home system consists of interconnected devices that monitor and control various aspects of a residential environment. These systems are commonly described using a three-layer IoT reference architecture~\cite{iot_architecture_2019, khan_iot_smarthome_2018}:

\begin{itemize}
    \item \textbf{Application Layer:} Software platforms that process sensor data, execute automation rules, and provide user interfaces for monitoring and control.
    
    \item \textbf{Network Layer:} Communication infrastructure that enables data transmission between devices. Common wireless technologies include Wi-Fi (IEEE~802.11), Zigbee (IEEE~802.15.4), and Bluetooth Low Energy (BLE)~\cite{smarthome_survey_2020}. Prior work has explored Wi-Fi-based smart home implementations using microcontrollers and mobile applications~\cite{bhatnagar_wifi_smarthome_2018}.
    
    \item \textbf{Perception Layer:} Sensors and actuators that interact with the physical environment, including temperature sensors, motion detectors, smart switches, and lighting controls.
\end{itemize}

The evolution of smart home technology has been driven by advances in microcontroller capabilities, wireless communication standards, and cloud computing infrastructure~\cite{smarthome_survey_2020}. Modern systems increasingly emphasize edge computing, where data processing occurs locally rather than in centralized cloud servers~\cite{edge_computing_iot_2016}.

% ============================================================================
% 2.2 MQTT Protocol
% ============================================================================
\section{MQTT Protocol}
\label{sec:mqtt}

Message Queuing Telemetry Transport (MQTT) is a lightweight publish-subscribe messaging protocol designed for constrained devices and low-bandwidth networks~\cite{mqtt_oasis_2019}. Developed by IBM in 1999, MQTT has become an established standard for IoT communications due to its low protocol overhead and simple implementation~\cite{mqtt_iot_survey_2017}.

Comparative studies have demonstrated MQTT's advantages over HTTP for IoT applications, including reduced network overhead and lower energy consumption~\cite{mqtt_performance_2018}.

Unlike traditional request-response protocols, MQTT employs a publish-subscribe model with a central broker:

\begin{itemize}
    \item \textbf{Publishers} send messages to specific topics without knowledge of subscribers.
    \item \textbf{Subscribers} register interest in topics and receive all messages published to those topics.
    \item \textbf{Broker} acts as an intermediary, routing messages from publishers to subscribers based on topic matching.
\end{itemize}
\begin{figure}[htbp]
    \centering
    \IfFileExists{images/MQTT_PublishSubscribeArchitecture.pdf}{%
        \includegraphics[width=0.95\textwidth]{images/MQTT_PublishSubscribeArchitecture.pdf}%
    }{%
        \fbox{\parbox{0.9\textwidth}{\centering
            Missing figure: \texttt{images/MQTT\_PublishSubscribeArchitecture.pdf}
        }}%
    }
    \caption{MQTT Publish-subscribe Architecture~\cite{emqx_pubsub_2023}}
    \label{fig:mqtt-pubsub}
\end{figure}

This decoupled architecture enables scalable many-to-many communication patterns suitable for IoT deployments.

\subsection{MQTT Protocol Characteristics}
\label{subsec:mqtt-characteristics}

MQTT is designed for reliable messaging in constrained and bandwidth-limited IoT environments, emphasizing low protocol overhead and a broker-mediated publish--subscribe model~\cite{mqtt_oasis_2019,mqtt_iot_survey_2017}. Key characteristics include:

\begin{itemize}
    \item \textbf{Lightweight control packets:} A compact fixed header and small message framing reduce bandwidth and parsing overhead compared to many request--response protocols.
    \item \textbf{Decoupled communication:} Publishers and subscribers do not need direct knowledge of each other, improving scalability and simplifying multi-producer/multi-consumer deployments.
    \item \textbf{Topic-based addressing and filtering:} Hierarchical topics and wildcard subscriptions enable flexible routing and selective consumption of device telemetry and control streams.
    \item \textbf{Session semantics:} Keep-alive, retained messages, and Last Will and Testament (LWT) support robustness in the presence of intermittent connectivity~\cite{mqtt_oasis_2019}.
\end{itemize}

MQTT topics use a hierarchical structure with forward slash separators, enabling flexible subscription patterns through single-level (\texttt{+}) and multi-level (\texttt{\#}) wildcards~\cite{mqtt_oasis_2019}:

\begin{table}[htbp]
    \centering
    \small
    \setlength{\tabcolsep}{4pt}
    \renewcommand{\arraystretch}{1.15}
    \caption{MQTT topic hierarchy and wildcard subscription patterns.}
    \label{tab:mqtt-topic-examples}
    \begin{tabular}{lll}
        	\toprule
        	\textbf{Concept} & \textbf{Example} & \textbf{Notes} \\
        \midrule
        State topic & \texttt{smarthome/bathroom/temperature/state} & leaf topic \\
        Single-level wildcard & \texttt{smarthome/bedroom/+/state} & one level \\
        Multi-level wildcard & \texttt{smarthome/\#} & any depth \\
        \bottomrule
    \end{tabular}
\end{table}

This hierarchical organization facilitates logical grouping of devices and supports pattern-based subscriptions for efficient message filtering.

\subsection{Quality of Service Levels}
\label{subsec:qos}

MQTT defines three Quality of Service (QoS) levels to balance reliability against overhead:

\begin{table}[htbp]
    \centering
    \caption{Comparison of MQTT Quality of Service (QoS) Levels~\cite{mqtt_oasis_2019}}
    \label{tab:mqtt-qos}
    \begin{tabular}{lp{8cm}l}
        \toprule
        \textbf{QoS Level} & \textbf{Description} & \textbf{Overhead} \\
        \midrule
        0 (At most once) & Fire and forget. No guarantee of delivery. & Lowest \\
        1 (At least once) & Guaranteed delivery, duplicates possible. Requires PUBACK. & Medium \\
        2 (Exactly once) & Guaranteed delivery, no duplicates. Four-step handshake. & Highest \\
        \bottomrule
    \end{tabular}
\end{table}

QoS 0 provides the lowest overhead but no delivery guarantees. QoS 1 ensures delivery through acknowledgment but may result in duplicates. QoS 2 guarantees exactly-once delivery at the cost of additional message exchanges.



% ============================================================================
% 2.3 Transport Layer Security
% ============================================================================
\section{Transport Layer Security}
\label{sec:tls}

Transport Layer Security (TLS) provides cryptographic security for communications over computer networks. In IoT contexts, TLS protects against eavesdropping, tampering, and impersonation attacks~\cite{iot_security_survey_2019}.

Standard TLS authenticates only the server to the client, verifying the server's identity through certificate validation. Mutual TLS (mTLS) extends this by requiring both parties to present certificates:

\begin{enumerate}
    \item Client initiates connection with ClientHello message.
    \item Server responds with certificate and requests client certificate.
    \item Client presents its certificate for server verification.
    \item Both parties complete key exchange and establish encrypted session.
\end{enumerate}

\begin{figure}[htbp]
    \centering
    % Source image: Cloudflare Learning Center (see citation in caption).
    \IfFileExists{images/how_tls_works-what_is_mutual_tls.png}{%
        \includegraphics[width=0.95\linewidth]{images/how_tls_works-what_is_mutual_tls.png}%
    }{%
        \fbox{\parbox{0.92\textwidth}{\centering
            Missing figure: \texttt{images/how\_tls\_works-what\_is\_mutual\_tls.png}
        }}%
    }
    \caption{Mutual TLS (mTLS) authentication concept and handshake overview~\cite{cloudflare_mtls_2024}}
    \label{fig:mtls-sequence}
\end{figure}

mTLS provides stronger security guarantees for IoT deployments by ensuring that only authorized devices can connect to the message broker.
\subsection{ECC vs RSA Cryptography}
\label{subsec:ecc-rsa}

Elliptic Curve Cryptography (ECC) offers equivalent security to RSA with significantly smaller key sizes, making it particularly suitable for resource-constrained IoT devices. According to NIST recommendations, a 128-bit security level corresponds to an RSA key size of 3072 bits, whereas an ECC key requires only 256 bits~\cite{NIST_SP_800_57}.

\begin{table}[H]
\centering
\caption{Comparison of ECC and RSA Key Sizes~\cite{NIST_SP_800_57}}
\label{tab:ecc-rsa}
\begin{tabular}{lcc}
\toprule
    \textbf{Security Strength} & \textbf{ECC Key Size} & \textbf{RSA Key Size} \\
\midrule
80-bit & 160 bits & 1024 bits \\
112-bit & 224 bits & 2048 bits \\
128-bit & \textbf{256 bits} & 3072 bits \\
\bottomrule
\end{tabular}
\end{table}

The computational efficiency of ECC becomes evident when analyzing performance on specific microcontroller platforms. Benchmarks reported by Oryx Embedded\footnote{\url{https://www.oryx-embedded.com/benchmark/espressif/}} for ESP32 (Xtensa LX6) and ESP32-S3 (Xtensa LX7) at 240~MHz show substantial latency differences across public-key algorithms~\cite{oryx_crypto_benchmark_esp32, oryx_crypto_benchmark_esp32s3}.

\begin{table}[H]
\centering
\caption{Digital Signature Performance on ESP32 platforms~\cite{oryx_crypto_benchmark_esp32, oryx_crypto_benchmark_esp32s3}}
\label{tab:crypto-signature-benchmark}
\begin{tabular}{lcccccc}
\toprule
\textbf{Algorithm} & \multicolumn{3}{c}{\textbf{ESP32 (LX6)}} & \multicolumn{3}{c}{\textbf{ESP32-S3 (LX7)}} \\
\cmidrule(lr){2-4} \cmidrule(lr){5-7}
& Sign & Verify & Total & Sign & Verify & Total \\
\midrule
RSA-3072 (HW)          & 465 ms & 314 ms & 779 ms & 315 ms & 57 ms & 372 ms \\
ECDSA P-256 (HW)       & 62 ms  & 57 ms  & 119 ms & 67 ms  & 60 ms & 127 ms \\
Ed25519 (SW)           & \textbf{29 ms}  & \textbf{28 ms}  & \textbf{57 ms} & \textbf{26 ms}  & \textbf{24 ms} & \textbf{50 ms} \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Key Exchange Performance on ESP32 Platforms~\cite{oryx_crypto_benchmark_esp32, oryx_crypto_benchmark_esp32s3}}
\label{tab:crypto-keyexchange-benchmark}
\begin{tabular}{lcccccc}
\toprule
\textbf{Algorithm} & \multicolumn{3}{c}{\textbf{ESP32 (LX6)}} & \multicolumn{3}{c}{\textbf{ESP32-S3 (LX7)}} \\
\cmidrule(lr){2-4} \cmidrule(lr){5-7}
& Keygen & Shared & Total & Keygen & Shared & Total \\
\midrule
ECDH P-256 (HW)        & 54 ms  & 54 ms  & 108 ms & 63 ms  & 62 ms & 125 ms \\
X25519 (SW)            & \textbf{17 ms}  & \textbf{16 ms}  & \textbf{33 ms} & \textbf{14 ms}  & \textbf{15 ms} & \textbf{29 ms} \\
\bottomrule
\end{tabular}
\end{table}

Notably, Ed25519 and X25519 in pure software outperform NIST P-256 with hardware acceleration by 2--4$\times$. This reflects the Curve25519 design goal of efficient arithmetic on general-purpose CPUs~\cite{bernstein_curve25519_2006}.

\subsection{Selection of Cryptographic Algorithms for TLS}
\label{subsec:curve25519}

Based on the performance analysis above, this thesis initially targeted the \textbf{Curve25519} cryptographic suite: \textbf{Ed25519} (EdDSA) for digital signatures and \textbf{X25519} for Elliptic Curve Diffie--Hellman (ECDH) key exchange. The selection was motivated by three primary factors:

\begin{itemize}
    \item \textbf{Efficiency on embedded CPUs:} The reported benchmarks show that Ed25519 and X25519 complete faster than the NIST P-256 alternatives on both ESP32 and ESP32-S3 (Tables~\ref{tab:crypto-signature-benchmark} and \ref{tab:crypto-keyexchange-benchmark}).
    \item \textbf{Implementation hardening:} X25519 is specified with a Montgomery-ladder construction that is commonly implemented in a constant-time style to reduce timing side channels~\cite{rfc7748, bernstein_curve25519_2006}. 
    \item \textbf{Parameter transparency and deterministic signing:} Curve25519 has been discussed as having more transparent parameter choices, and SafeCurves\footnote{\url{https://safecurves.cr.yp.to/}} highlights ``rigidity'' as a criterion where NIST P-256 is rated negatively due to opaque seeds~\cite{safecurves_2017}. For authentication, Ed25519 (EdDSA) uses deterministic nonce generation as standardized in RFC 8032, reducing reliance on runtime randomness during signing~\cite{rfc8032, bernstein_ed25519_2012}. This design addresses a fundamental weakness in ECDSA, where poor random number generation during signing can leak the private key---a critique extensively documented by Bernstein~\cite{bernstein_ecdsa_blog_2014}.
\end{itemize}

\subsubsection{Library Limitations and Hybrid Approach}
\label{subsubsec:hybrid-tls}

During implementation, a practical limitation was encountered: the ESP-IDF framework's underlying TLS library (Mbed~TLS) supports X25519 for ECDH key exchange but does not currently support Ed25519 (EdDSA) for X.509 certificate signatures~\cite{esp_tls_2024}. The ESP-TLS API documentation explicitly lists only \texttt{SECP256R1} and \texttt{SECP384R1} as supported ECDSA curves for certificate operations. This limitation is documented in the Mbed~TLS project issue tracker\footnote{\url{https://github.com/Mbed-TLS/mbedtls/issues/2452}}, where Ed25519 certificate support has been requested as a feature enhancement~\cite{mbedtls_ed25519_issue}. According to the official Mbed~TLS roadmap\footnote{\url{https://mbed-tls.readthedocs.io/en/latest/roadmap/}}, EdDSA support for certificates is planned for future releases~\cite{mbedtls_roadmap_2024}.

It is worth noting that alternative TLS libraries exist for embedded systems that provide full Curve25519 support. wolfSSL\footnote{\url{https://www.wolfssl.com/}}, a lightweight embedded TLS library, offers complete Ed25519 and X25519 support, including Ed25519-based X.509 certificate signatures~\cite{wolfssl_2024}. The ESP-IDF framework officially supports wolfSSL as an alternative to Mbed~TLS through its component system~\cite{esp_tls_2024}. wolfSSL is designed for resource-constrained environments and supports TLS~1.3 with progressive cipher suites. However, for this thesis, ESPHome was chosen as the firmware framework due to its simplified YAML-based configuration and native Home Assistant integration. ESPHome currently uses Mbed~TLS as its TLS backend and does not expose wolfSSL as a configuration option, making the hybrid approach (P-256 certificates with X25519 key exchange) the practical choice within this framework. For deployments requiring pure Curve25519-based mTLS, switching to native ESP-IDF with wolfSSL would be necessary.

\paragraph{Hybrid TLS Configuration.}
To address this limitation while maximizing performance, this thesis adopts a \textbf{hybrid cryptographic approach} that combines the strengths of both algorithm families:

\begin{itemize}
    \item \textbf{Certificate signatures:} ECDSA with NIST P-256 (\texttt{prime256v1}), which is fully supported by ESP-TLS for X.509 certificate parsing and verification.
    \item \textbf{Key exchange:} X25519, automatically negotiated during TLS~1.3 handshake when the \texttt{supported\_groups} extension includes \texttt{x25519} on both endpoints~\cite{rfc8446}.
\end{itemize}

This separation is possible because TLS~1.3 decouples the authentication mechanism (certificate signatures) from the key exchange mechanism (ephemeral Diffie--Hellman). As specified in RFC~8446, the signature algorithm used in certificates is independent of the key exchange group negotiated in the handshake~\cite{rfc8446}.

\paragraph{Performance Analysis of the Hybrid Approach.}
Table~\ref{tab:hybrid-performance} presents the estimated cryptographic latency for a complete mTLS handshake under different configurations. The hybrid approach (P-256 signatures + X25519 key exchange) achieves a favorable balance: it avoids the slow RSA operations while leveraging X25519's efficiency for the latency-critical key exchange phase.

\begin{table}[H]
\centering
\caption{Estimated TLS Handshake Cryptographic Latency on ESP32-S3~\cite{oryx_crypto_benchmark_esp32s3}}
\label{tab:hybrid-performance}
\begin{tabular}{lccc}
\toprule
\textbf{Configuration} & \textbf{Signature (Verify)} & \textbf{Key Exchange} & \textbf{Total} \\
\midrule
RSA-3072 + ECDH P-256       & 57 ms  & 125 ms & 182 ms \\
ECDSA P-256 + ECDH P-256    & 60 ms  & 125 ms & 185 ms \\
\textbf{ECDSA P-256 + X25519 (Hybrid)} & 60 ms  & \textbf{29 ms}  & \textbf{89 ms} \\
Ed25519 + X25519 (Ideal)\textsuperscript{*}    & 24 ms  & 29 ms  & 53 ms \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\small
\item \textsuperscript{*}Theoretical; Ed25519 certificate signatures not supported by ESP-TLS.
\end{tablenotes}
\end{table}

The hybrid configuration reduces total cryptographic latency by approximately 52\% compared to the pure P-256 configuration (89~ms vs 185~ms), primarily due to X25519's 4$\times$ faster key exchange. Certificate verification occurs only once per connection establishment, whereas the session key derived from ECDH protects all subsequent application data. For battery-powered IoT devices that employ deep-sleep modes and wake periodically to transmit sensor data, each wake cycle requires re-establishing the TLS connection~\cite{esp_sleep_modes_2024}. Therefore, optimizing key exchange latency directly reduces the energy consumed during these frequent reconnection events.

% ============================================================================
% 2.4 Home Assistant and ESPHome
% ============================================================================

\section{Home Assistant and ESPHome}
\label{sec:ha-esphome}

\textbf{Home Assistant}\footnote{\url{https://www.home-assistant.io/}} is an open-source home automation platform designed to run on local hardware~\cite{homeassistant_2024}. The platform is distributed as Docker containers built on Alpine Linux base images, providing a lightweight footprint suitable for embedded systems and single-board computers~\cite{ha_docker_base_2024}. Key features include:

\begin{itemize}
    \item \textbf{Integration Support:} Extensive integration ecosystem covering a wide range of commercial and DIY devices and services.
    \item \textbf{Local Control:} Local-first operation with optional cloud connectivity, enabling continued functionality even when external services are unavailable.
    \item \textbf{Automation Engine:} Flexible automation via YAML configuration and a visual editor, supporting complex rule-based behaviors.
    \item \textbf{Dashboard System:} Customizable dashboards for real-time monitoring, control, and status visualization across devices.
\end{itemize}

In addition, Home Assistant supports MQTT Discovery, which allows devices to be automatically registered by publishing configuration messages to predefined discovery topics.

For ESP32-based devices, firmware development and integration with Home Assistant are facilitated by the ESPHome framework.

	\textbf{ESPHome}\footnote{\url{https://esphome.io/}} is a firmware framework that generates custom firmware from YAML configuration files~\cite{esphome_2024}. It supports a range of microcontroller platforms, including ESP8266, ESP32 variants, RP2040, and select LibreTiny-based chipsets. Its declarative configuration style is conceptually similar to earlier Wi-Fi-based appliance control systems that emphasized simplified device programming~\cite{xiao_wifi_iot_2018}. Key capabilities include:

\begin{itemize}
    \item \textbf{Sensor Support:} Native drivers for hundreds of sensor types.
    \item \textbf{Native API:} Low-latency direct communication with Home Assistant.
    \item \textbf{MQTT Support:} Full MQTT client with TLS/mTLS capability.
    \item \textbf{OTA Updates:} Over-the-air firmware updates via WiFi.
    \item \textbf{Local Automation:} On-device automation without external dependencies.
\end{itemize}

The declarative YAML configuration approach reduces development complexity while maintaining flexibility through lambda expressions for custom logic.

Beyond built-in integrations, Home Assistant supports community-developed components distributed via the Home Assistant Community Store (HACS)\footnote{\url{https://hacs.xyz/}}. This mechanism enables integration of devices from vendors who do not provide official Home Assistant support, including official manufacturer-provided integrations such as the Xiaomi Home Integration\footnote{\url{https://github.com/XiaoMi/ha_xiaomi_home}}. Such extensibility allows users to aggregate heterogeneous device ecosystems under a single local-first platform, contrasting with commercial solutions that typically rely on vendor-specific cloud infrastructure.
% ============================================================================
% 2.5 Edge Computing and Unix-like Systems
% ============================================================================
\section{Edge Computing and Unix-like Systems}
\label{sec:edge-unix}

Edge computing moves parts of data processing closer to the data source, reducing latency and upstream bandwidth requirements and enabling continued operation when cloud connectivity is degraded~\cite{edge_computing_iot_2016}. 

\begin{table}[htbp]
    \centering
    \caption{Comparison between Cloud Computing and Edge Computing in IoT Contexts~\cite{edge_computing_iot_2016}}
    \label{tab:edge-vs-cloud}
    \begin{tabular}{lll}
        \toprule
        \textbf{Feature} & \textbf{Cloud Computing} & \textbf{Edge Computing} \\
        \midrule
        \textbf{Latency} & High (WAN-dependent) & Low (near real-time) \\
        \textbf{Bandwidth} & High usage (raw data) & Low usage (processed data) \\
        \textbf{Privacy} & Data leaves premises & Data stays local \\
        \textbf{Processing Power} & Elastic (scalable) & Constrained (MCU/CPU) \\
        \textbf{Dependency} & Internet connection & Local power \\
        \bottomrule
    \end{tabular}
\end{table}

In smart home deployments, a central architectural choice is whether integration logic and data processing are executed in a vendor-operated cloud or on user-controlled infrastructure.

This thesis adopts a \emph{server-based} design and implements the main software components---MQTT broker, Home Assistant, and the sensor simulator---on Unix-like systems within a controlled local environment. The motivation is not peak performance alone, but operational robustness and measurability, which are central for benchmarking and reproducible evaluation. Additionally, the open-source tooling and active community support lower the barrier for individual deployment and learning:

\begin{itemize}
    \item \textbf{Operational maturity:} The process model, service supervision, and standard administration tooling support repeatable deployments and recovery workflows~\cite{kerrisk_2010}.
    \item \textbf{Security ecosystem:} Linux platforms provide widely deployed TLS stacks and cryptographic libraries, simplifying secure broker deployments and certificate management~\cite{openssl_2024}.
    \item \textbf{Observability for evaluation:} System-level tooling enables measurement of CPU scheduling, memory pressure, filesystem behavior, and network throughput, which is required to relate application metrics to underlying bottlenecks~\cite{gregg_systems_performance_2020}.
\end{itemize}

In the experimental setup, the MQTT broker runs on a Debian-based server, and Home Assistant is deployed via the Home Assistant Operating System (HAOS), a Linux-based operating system built using Buildroot and optimized to host Home Assistant~\cite{haos_buildroot_2024}. The sensor simulator is implemented in Python, enabling cross-platform execution, controllable entity emulation, and reproducible benchmarking across diverse host environments.


