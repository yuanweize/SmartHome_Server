\chapter{Evaluation and Results}
\label{ch:evaluation}

This chapter presents the evaluation methodology and experimental results, including performance metrics, security analysis, reliability assessment, and comparison with commercial solutions.

% ============================================================================
% 5.1 Test Environment
% ============================================================================
\section{Test Environment}
\label{sec:test-env}

The evaluation was conducted using the production deployment described in Chapter~\ref{ch:architecture}, specifically the system components summarized in Table~\ref{tab:system-components}. To facilitate cross-network benchmarking, the Python simulator was deployed on a VPS in Hong Kong (2~vCPU x86\_64, 2\,GB RAM, Debian~12), providing geographic separation from the European infrastructure and enabling realistic wide-area network latency measurements.

% ============================================================================
% 5.2 Performance Metrics
% ============================================================================
\section{Performance Metrics}
\label{sec:performance}

Network path latencies were measured using \texttt{mtr} with approximately 200 samples per path. Table~\ref{tab:network-latency} presents the measured round-trip times for key communication paths in the deployed system.

\begin{table}[htbp]
\centering
\caption{Network Path Latency Measurements (RTT)}
\label{tab:network-latency}
\begin{tabular}{llccc}
\toprule
\textbf{Path} & \textbf{Description} & \textbf{Avg (ms)} & \textbf{Best (ms)} & \textbf{Worst (ms)} \\
\midrule
HKG $\rightarrow$ NUE & Simulator to EMQX broker & 171.1 & 170.7 & 174.8 \\
FARM $\rightarrow$ NUE & SSL termination to broker & 6.4 & 6.3 & 6.6 \\
NUE $\rightarrow$ HAOS & Broker to Home Assistant & 8.4 & 8.0 & 9.4 \\
FARM $\rightarrow$ HAOS & SSL termination to HA & 7.7 & 7.6 & 8.2 \\
HAOS $\rightarrow$ ESP32 & Native API (LAN) & 0.3 & 0.2 & 0.4 \\
\bottomrule
\end{tabular}
\end{table}

The end-to-end latency for MQTT messages from the Hong Kong simulator to Home Assistant in Prague comprises the HKG--NUE path ($\sim$171\,ms) plus the NUE--HAOS path ($\sim$8\,ms), totaling approximately 180\,ms. In contrast, Native API connections within the local network achieve sub-millisecond latency, validating the dual-connection architecture design decision for local device responsiveness.

\subsection{TLS Handshake Performance}
\label{subsec:tls-handshake}

The deployed system uses X25519 for key exchange. Due to ESP-IDF / ESP-TLS constraints on X.509 certificate signature algorithms, the deployed certificate chain uses ECDSA with NIST P-256 (\texttt{prime256v1}) for authentication, while retaining X25519 for ECDHE key exchange during TLS~1.3 handshake. As established in Section~\ref{subsec:ecc-rsa}, NIST SP 800-57 confirms that 256-bit ECC provides equivalent security to 3072-bit RSA with significantly smaller key sizes~\cite{NIST_SP_800_57}.

To contextualize the cost of cryptographic primitives during connection establishment, this thesis references the third-party microbenchmark published by Oryx Embedded for ESP32-S3 (Xtensa LX7 @ 240\,MHz), generated with CycloneCRYPTO 2.5.0 and compiled with GCC at optimization level \texttt{-O3}~\cite{oryx_crypto_benchmark_esp32s3}. The report lists ECDH (X25519) at approximately 14\,ms for public key generation and 15\,ms for shared secret computation. These figures are used as indicative reference points; absolute timings depend on the specific TLS stack, build configuration, and hardware acceleration availability.

\subsection{Hybrid TLS Configuration Verification}
\label{subsec:hybrid-verification}

To validate the hybrid cryptographic approach described in Section~\ref{subsubsec:hybrid-tls}, the deployed TLS configuration was tested using OpenSSL's diagnostic client. Table~\ref{tab:tls-verification} summarizes the negotiated parameters observed during mTLS handshake with the production EMQX broker.

\begin{table}[htbp]
\centering
\caption{TLS Handshake Verification Results}
\label{tab:tls-verification}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Negotiated Value} \\
\midrule
Protocol & TLS 1.3 \\
Cipher Suite & \texttt{TLS\_AES\_256\_GCM\_SHA384} \\
Key Exchange (Peer Temp Key) & X25519, 253 bits \\
Signature Algorithm & \texttt{ecdsa\_secp256r1\_sha256} \\
Server Certificate & ECDSA P-256 (prime256v1) \\
Client Certificate & ECDSA P-256 (prime256v1) \\
Certificate Verification & OK \\
\bottomrule
\end{tabular}
\end{table}

The verification confirms that the hybrid configuration operates as designed: certificates are signed using ECDSA P-256 (\texttt{ecdsa\_secp256r1\_sha256}), while key exchange utilizes X25519. This result demonstrates that TLS~1.3 successfully decouples the certificate signature algorithm from the key exchange mechanism, enabling optimization of each independently~\cite{rfc8446}.

A comparative test was conducted by explicitly restricting the key exchange group to P-256:
\begin{verbatim}
openssl s_client -connect mqtt.eurun.top:8883 \
  -tls1_3 -groups P-256
\end{verbatim}
This test confirmed fallback behavior: when X25519 is excluded from the \texttt{supported\_groups} extension, the handshake successfully negotiates ECDH with P-256 instead (\texttt{Peer Temp Key: ECDH, prime256v1, 256 bits}). This demonstrates the system's backward compatibility while preferring X25519 when available.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{images/25519.png}
\caption{TLS handshake with X25519 key exchange (default configuration).}\vspace{-0.5em}
\label{fig:tls-x25519}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{images/p256.png}
\caption{TLS handshake with P-256 key exchange (fallback test using \texttt{-groups P-256}).}\vspace{-0.5em}
\label{fig:tls-p256}
\end{figure}

\subsection{mTLS Connection Latency Benchmark}
\label{subsec:handshake-latency}

To empirically measure the end-to-end mTLS connection establishment latency, the Python simulator's handshake benchmark mode (Python 3.11.2, paho-mqtt 1.6) was executed from the FARM host (Frankfurt, Germany) to an EMQX 6.0.0 broker (Nuremberg, Germany). This path exhibits a network RTT of approximately 6.4\,ms (Table~\ref{tab:network-latency}), minimizing the impact of network propagation delay on the measurement.

Table~\ref{tab:handshake-latency} summarizes the measured mTLS handshake latency over 800 connection samples. The complete benchmark methodology and raw data are provided in Appendix~\ref{app:handshake-metrics}.

\begin{table}[htbp]
\centering
\caption{mTLS Handshake Latency Benchmark (FARM $\rightarrow$ NUE, $n=800$)}
\label{tab:handshake-latency}
\begin{tabular}{lccccccccc}
\toprule
\textbf{Mean} & \textbf{P50} & \textbf{P90} & \textbf{P95} & \textbf{P99} & \textbf{Min} & \textbf{Max} & \textbf{Std} & \textbf{95\% CI} \\
\midrule
80.50 & 80.55 & 91.61 & 92.82 & 96.79 & 67.84 & 104.07 & 7.49 & [79.98, 81.02] \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\small
\item All values in milliseconds (ms). P$n$ denotes the $n$th percentile; Std = standard deviation; 95\% CI = 95\% confidence interval for the mean.
\end{tablenotes}
\end{table}

The measured mean latency of 80.50\,ms represents the complete mTLS connection establishment time from an x86\_64 host, including network round-trips and cryptographic operations. This benchmark primarily validates the network path stability and the EMQX broker's mTLS configuration---it does not reflect ESP32 client performance due to fundamental differences in hardware capability (x86 vs.\ Xtensa LX7) and TLS stack (OpenSSL vs.\ MbedTLS).

For ESP32-S3 performance estimation, Table~\ref{tab:hybrid-performance} provides cryptographic primitive timings (approximately 89\,ms for handshake-related operations). Combined with network RTT, total connection latency for ESP32 clients on similar paths would be approximately 100--120\,ms---well within acceptable bounds for IoT reconnection scenarios.

The P99 latency of 96.79\,ms confirms that even worst-case connection times remain under 100\,ms, which is suitable for IoT applications requiring responsive reconnection behavior. The narrow 95\% confidence interval ($\pm$0.52\,ms) and zero connection failures across 800 samples demonstrate excellent measurement repeatability and connection reliability.

\subsection{Scalability Testing}
\label{subsec:scalability}

The Python simulator was used to evaluate system scalability by progressively increasing the number of simulated devices. Each test configuration was monitored for approximately 5 minutes to capture steady-state resource utilization. Monitoring screenshots from EMQX Dashboard, broker system metrics, and Home Assistant are provided in Appendix~\ref{app:scalability-screenshots}.

\begin{table}[htbp]
\centering
\caption{Scalability Test Results}
\label{tab:scalability}
\begin{tabular}{lccc}
\toprule
\textbf{Devices} & \textbf{Messages/sec} & \textbf{Broker CPU (\%)} & \textbf{HA CPU (\%)} \\
\midrule
100 & $\sim$229 & 3.72 & 1.1 \\
1,000 & $\sim$1,618 & 4.03 & 1.4 \\
\bottomrule
\end{tabular}
\end{table}

The test results demonstrate that the EMQX broker handles 1,000 concurrent simulated devices with minimal resource impact---CPU utilization increased by only 0.31 percentage points (from 3.72\% to 4.03\%) when scaling from 100 to 1,000 devices, while message throughput increased proportionally from 229 to 1,618 messages per second. Home Assistant CPU utilization remained low at 1.1--1.4\%, indicating substantial headroom for additional devices.

Testing beyond 1,000 devices was limited by the simulator host's computational capacity (2~vCPU VPS). At 5,000 devices, the simulator process itself reached 100\% CPU utilization, making further scalability measurements unreflective of broker or Home Assistant limits. Nevertheless, the observed linear relationship between device count and message throughput, combined with near-constant broker CPU utilization, suggests the architecture can support significantly larger deployments. EMQX documentation reports theoretical limits of over 100 million concurrent connections in clustered configurations\footnote{\url{https://www.emqx.com/en/blog/reaching-100m-mqtt-connections-with-emqx-5-0}}~\cite{emqx_2024}.


% ============================================================================
% 5.3 Security and Reliability
% ============================================================================
\section{Security and Reliability}
\label{sec:security-reliability}

The implemented security architecture addresses common IoT threat vectors through transport layer protection. All MQTT communications are encrypted using TLS 1.2/1.3, preventing eavesdropping and tampering~\cite{rfc8446}. Mutual TLS (mTLS) authentication ensures that only devices with valid client certificates can connect to the broker, mitigating unauthorized access and device impersonation attacks~\cite{cloudflare_mtls_2024}.

The current implementation uses a single Certificate Authority for all certificates. While suitable for small deployments, production systems should consider intermediate CAs, automated certificate rotation, and CRL distribution.

The system demonstrated stable operation during the development and testing period. ESP32 nodes exhibited resilient behavior, automatically reconnecting after WiFi disconnections or broker restarts. The dual-connection architecture proved valuable during internet outages, maintaining local control capability through Native API while MQTT connectivity was disrupted.

% ============================================================================
% 5.4 Comparison with Commercial Solutions
% ============================================================================
\section{Comparison with Commercial Solutions}
\label{sec:comparison}

This section compares the implemented system with commercial smart home platforms, analyzing trade-offs between different approaches.

Xiaomi's Mi Home platform employs a cloud-centric architecture where device states are synchronized via cloud-based MQTT subscription and commands are transmitted through HTTP APIs\footnote{\url{https://www.home-assistant.io/integrations/xiaomi_miio/}}. Strengths include competitive device pricing, intuitive mobile application, and wide device ecosystem. Limitations include cloud dependency for most features (though local control is available for some devices via gateway or LAN protocols), regional server restrictions, and limited customization options. The Xiaomi Air Purifier integrated in this thesis demonstrates interoperability through Home Assistant's Xiaomi Miio integration.

Voice-controlled platforms from Amazon and Google process commands through cloud-based speech recognition. Research has documented privacy implications of voice assistant data collection~\cite{voice_assistant_privacy_2019}. The Matter protocol initiative aims to improve cross-platform compatibility~\cite{matter_spec_2022}. Due to device availability constraints, analysis relies on published documentation and academic studies.

\subsection{Comparative Analysis}
\label{subsec:comparative}

Table~\ref{tab:platform-comparison} presents a comparison across key evaluation criteria.

\begin{table}[htbp]
\centering
\caption{Platform Comparison Matrix}
\label{tab:platform-comparison}
\begin{threeparttable}
\begin{tabular}{lcccc}
\toprule
\textbf{Criterion} & \textbf{This System} & \textbf{Xiaomi} & \textbf{Alexa} & \textbf{Google} \\
\midrule
Data Storage & Local & Cloud & Cloud & Cloud \\
Privacy Control & Full & Limited & Limited & Limited \\
Customization & High & Low & Medium & Medium \\
Setup Complexity & Medium & Low & Low & Low \\
Offline Capability & Full & Partial & Minimal & Minimal \\
Vendor Independence & Full & None & None & None \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\small
\item Premium features may require subscription on commercial platforms
\end{tablenotes}
\end{threeparttable}
\end{table}

The fundamental architectural difference lies in data storage location. Commercial platforms transmit sensor data to cloud servers, where it may be analyzed for service improvement, used for targeted advertising, or subject to data breaches. The implemented system maintains all data locally.

Vendor dependency creates sustainability risks, as demonstrated by historical platform discontinuations. Open-source solutions eliminate this dependency by enabling community maintenance independent of any single vendor's business decisions.

The comparison reveals a fundamental trade-off between convenience and control. The self-hosted approach has higher upfront complexity but offers greater control and learning value. Open-source frameworks like ESPHome can significantly lower the entry barrier compared to writing custom firmware~\cite{esphome_2024,homeassistant_2024}. Commercial ecosystems minimize initial setup complexity but introduce stronger vendor dependency~\cite{iot_vendor_lockin_2021}.

The growing availability of Matter-compatible devices may reduce the technical barrier to local-first smart home deployments, potentially expanding adoption beyond technically sophisticated users.



# [CodeRabbit Audit Trigger 1769364389]
