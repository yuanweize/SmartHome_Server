\chapter{Implementation}
\label{ch:implementation}

This chapter details the implementation of all system components, including hardware sensor nodes, software simulator, MQTT broker configuration, and integration with Home Assistant.

% ============================================================================
% 4.1 Hardware Implementation
% ============================================================================
\section{Hardware Implementation}
\label{sec:hardware}

Two ESP32-based sensor nodes were implemented to demonstrate different IoT paradigms: edge intelligence and traditional environment sensing. The ESP32 platform was selected for its combination of dual-core processing, WiFi connectivity, and extensive peripheral support~\cite{esp32_datasheet_2024}.

\subsection{ESP32-S3 Edge Intelligence Node}
\label{subsec:esp32s3}

The ESP32-S3 node serves as an edge computing platform, performing local signal processing to reduce cloud dependency and enable real-time responses~\cite{esp32s3_datasheet_2024}.

\begin{figure}[htbp]
    \centering
    \IfFileExists{images/ESP32-S3-WROOM-1.drawio.png}{%
        \includegraphics[width=0.95\linewidth,height=0.4\textheight,keepaspectratio]{images/ESP32-S3-WROOM-1.drawio.png}%
    }{%
        \fbox{\parbox{0.95\linewidth}{\centering
            Missing figure: \texttt{images/ESP32-S3-WROOM-1.drawio.png}
        }}%
    }
    \caption{ESP32-S3 edge intelligence node with labeled sensor components.}
    \label{fig:esp32s3-hardware}
\end{figure}

\begin{table}[htbp]
\centering
\caption{ESP32-S3 Node Sensor Configuration}
\label{tab:esp32s3-sensors}
\begin{tabular}{llll}
\toprule
\textbf{Sensor} & \textbf{Model} & \textbf{Measurement} & \textbf{Interface} \\
\midrule
Barometric & BMP180 & Temperature, Pressure & I2C \\
Motion & MPU6050 (GY-521) & 6-axis Accelerometer/Gyro & I2C \\
Acoustic & KY-037 & Sound Level & ADC \\
\bottomrule
\end{tabular}
\end{table}

The BMP180 barometric sensor and MPU6050 inertial measurement unit share the same I2C bus (GPIO4 for SCL, GPIO5 for SDA). This is possible because the I2C protocol supports multiple devices on a single two-wire bus through 7-bit addressing---each device responds only to its unique address (BMP180: \texttt{0x77}, MPU6050: \texttt{0x68})~\cite{i2c_spec_2021}. The shared-bus architecture reduces GPIO consumption from four pins to two while enabling bidirectional communication with both sensors.

Table~\ref{tab:esp32s3-pinout} details the complete GPIO assignments and sensor module connections for the ESP32-S3 node. Each sensor module exposes multiple pins, but only a subset is required for basic operation; unused pins either provide redundant functionality or optional features not utilized in this implementation.

\begin{table}[htbp]
\centering
\caption{ESP32-S3 Node Pin Connections and Sensor Module Details}
\label{tab:esp32s3-pinout}
\resizebox{\linewidth}{!}{%
\begin{tabular}{lllll}
\toprule
\textbf{Module} & \textbf{Pin} & \textbf{ESP32-S3 GPIO} & \textbf{Function} & \textbf{Notes} \\
\midrule
\multirow{7}{*}{MPU6050\footnotemark[1]} 
  & VCC & 3V3 & Power (2.375--3.46\,V) & --- \\
  & GND & GND & Ground & --- \\
  & SCL & GPIO4 & I2C Clock & Shared with BMP180 \\
  & SDA & GPIO5 & I2C Data & Shared with BMP180 \\
  & XDA/XCL & --- & Aux I2C & --- \\
  & AD0 & --- & Address select & Unconnected = 0x68 \\
  & INT & --- & Interrupt & --- \\
\midrule
\multirow{4}{*}{BMP180\footnotemark[2]} 
  & VIN & 3V3 & Power (1.8--3.6\,V) & --- \\
  & GND & GND & Ground & --- \\
  & SCL & GPIO4 & I2C Clock & Shared with MPU6050 \\
  & SDA & GPIO5 & I2C Data & Shared with MPU6050 \\
\midrule
\multirow{4}{*}{KY-037\footnotemark[3]} 
  & VCC & 3V3 & Power (3.3--5\,V) & --- \\
  & GND & GND & Ground & --- \\
  & AO & GPIO6 & Analog output & Continuous sound level \\
  & DO & --- & Digital output & Threshold via potentiometer \\
\bottomrule
\end{tabular}%
}
\end{table}
\footnotetext[1]{\url{https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf}}
\footnotetext[2]{\url{https://cdn-shop.adafruit.com/datasheets/BST-BMP180-DS000-09.pdf}}
\footnotetext[3]{\url{https://www.espboards.dev/sensors/ky-037/}}

The firmware execution flow is depicted in Figure~\ref{fig:esp32s3-flowchart}. Upon boot, the device loads TLS configuration from \texttt{sdkconfig} and connects to WiFi. The subsequent MQTT connection triggers an mTLS handshake using ECDSA P-256 for certificate verification and X25519 for ephemeral key exchange (TLS~1.3). Sensor acquisition operates at differentiated rates: MPU6050 at 10\,Hz for fall detection, BMP180 at 0.2\,Hz for environmental monitoring, and KY-037 at 5\,Hz for acoustic sampling. Calibrated inertial data feeds the edge computing pipeline, which computes SMV and angular velocity for threshold-based fall detection.

\begin{figure}[H]
    \centering
    \setlength{\abovecaptionskip}{2pt}
    \setlength{\belowcaptionskip}{0pt}
    \IfFileExists{images/ESP32S3_FC.png}{%
        \includegraphics[width=\linewidth,height=0.92\textheight,keepaspectratio]{images/ESP32S3_FC.png}%
    }{%
        \fbox{\parbox{0.95\linewidth}{\centering
            Missing figure: \texttt{images/ESP32S3_FC.png}
        }}%
    }
    \caption{ESP32-S3 firmware execution flowchart: initialization with mTLS handshake (ECDSA P-256 + X25519), multi-rate sensor acquisition, edge computing for fall detection, and MQTT state publishing. The complete firmware listing is provided in Appendix~\ref{app:esp32s3-config}.}
    \label{fig:esp32s3-flowchart}
\end{figure}

The ESP32-S3's vector instruction set enables efficient implementation of edge computing algorithms. Table~\ref{tab:esp32s3-algorithms} summarizes the implemented edge algorithms, including a threshold-based fall detection algorithm adapted from Huynh et al.~\cite{huynh2015fall}.

\begin{table}[htbp]
\centering
\caption{ESP32-S3 Edge Computing Algorithms}
\label{tab:esp32s3-algorithms}
\begin{tabular}{lll}
\toprule
\textbf{Algorithm} & \textbf{Formula} & \textbf{Purpose} \\
\midrule
Resultant G-Force & $\text{SMV} = \sqrt{a_x^2 + a_y^2 + a_z^2}$ & Impact detection \\
Dynamic Vibration & $|G - 1.0|$ & Motion isolation \\
Angular Velocity Mag. & $\omega = \sqrt{\omega_x^2 + \omega_y^2 + \omega_z^2}$ & Rotation detection \\
Acoustic Peak & ADC threshold & Sound event \\
\bottomrule
\end{tabular}
\end{table}

The fall detection algorithm implements a dual-threshold approach adapted from Huynh et al.~\cite{huynh2015fall}, which combines accelerometer and gyroscope data to distinguish falls from normal activities. A fall event is detected only when both the Signal Magnitude Vector (SMV) exceeds $2.4\,\text{G}$ and the angular velocity magnitude exceeds $240\,^{\circ}/\text{s}$. In the original study (36 subjects, 702 movements), this dual-sensor approach achieved 96.3\% sensitivity and 96.2\% specificity, compared to 82.72\% specificity with accelerometer-only detection---the gyroscope data significantly reduces false positives from high-acceleration activities such as running.

It should be noted that gyroscope utility depends on the detection methodology. Casilari et al.~\cite{casilari2020gyroscope} evaluated CNN-based classification on the SisFall dataset and found that accelerometer-only input outperformed combined accelerometer-gyroscope input. This suggests that threshold-based algorithms benefit from explicit rotational velocity checks, whereas deep learning architectures can implicitly extract discriminative features from acceleration signals alone.

For this implementation, the threshold-based approach was selected for several practical reasons. First, it provides computational efficiency suitable for the ESPHome framework, which does not natively support neural network inference. Second, the explicit dual-threshold logic offers interpretable detection decisions, facilitating debugging and parameter tuning. Third, the algorithm requires minimal memory footprint compared to CNN models.

Nevertheless, the ESP32-S3 platform offers significant potential for future enhancement through its vector instruction extensions and the ESP-NN optimized neural network kernels\footnote{\url{https://github.com/espressif/esp-nn}}~\cite{esp_nn_2024}. According to Espressif's benchmarks\footnote{\url{https://github.com/espressif/esp-tflite-micro\#performance-comparison}}, TensorFlow Lite Micro with ESP-NN achieves a 42$\times$ speedup on ESP32-S3 compared to unoptimized execution, reducing the inference time for a person detection model from 2300\,ms to just 54\,ms~\cite{tflite_micro_espressif_2024}. This performance demonstrates that the CNN-based fall detection approach recommended by Casilari et al. is feasible on ESP32-S3 hardware. Such an upgrade would require migrating from ESPHome to the native ESP-IDF framework with TFLite Micro integration, potentially achieving higher detection accuracy with accelerometer-only input while eliminating the gyroscope sensor cost. This represents a promising direction for future development.

Figure~\ref{fig:fall-detection-flowchart} illustrates the real-time fall detection algorithm executed on the ESP32-S3. Each sensor cycle computes SMV from tri-axial accelerometer readings and angular velocity magnitude from gyroscope data; both values must exceed their thresholds simultaneously to trigger a fall event, minimizing false positives from high-impact activities.

\begin{figure}[htbp]
    \centering
    \IfFileExists{images/Fall_FC.png}{%
        \includegraphics[width=0.85\linewidth,height=0.75\textheight,keepaspectratio]{images/Fall_FC.png}%
    }{%
        \fbox{\parbox{0.75\linewidth}{\centering Fall Detection Flowchart (Fall\_FC.png not found)}}
    }
    \caption{Fall detection algorithm flowchart: dual-threshold decision logic using SMV ($>2.4\,\text{G}$) and angular velocity ($>240\,^{\circ}/\text{s}$) for robust fall event classification.}
    \label{fig:fall-detection-flowchart}
\end{figure}

\subsubsection{MPU6050 Sensor Calibration}
\label{subsubsec:mpu6050-calibration}

MEMS inertial sensors such as the MPU6050 exhibit systematic bias errors---defined as the average output when no input is applied~\cite{ieee_inertial_terminology_2019}---that must be compensated through calibration. The calibration procedure follows standard zero-offset compensation: the sensor is placed on a level surface in a stationary state, and the deviation from expected values is measured over multiple samples~\cite{mpu6050_datasheet_2013}.

Table~\ref{tab:mpu6050-calibration} presents the calibration parameters derived from stationary measurements. For the accelerometer, the X and Y axes should read zero when level, while the Z-axis should read $-g \approx -9.807\,\text{m/s}^2$ (with the sensor chip facing upward). For the gyroscope, all three axes should read zero when stationary.

\begin{table}[htbp]
\centering
\caption{MPU6050 Calibration Parameters from Stationary Measurements}
\label{tab:mpu6050-calibration}
\begin{tabular}{llrrrr}
\toprule
\textbf{Axis} & \textbf{Type} & \textbf{Expected} & \textbf{Raw} & \textbf{Offset} & \textbf{Calibrated} \\
\midrule
$a_x$ & Accel. & $0\,\text{m/s}^2$ & $+0.853$ & $-0.877$ & $-0.024$ \\
$a_y$ & Accel. & $0\,\text{m/s}^2$ & $-0.173$ & $-0.145$ & $-0.318$ \\
$a_z$ & Accel. & $-9.807\,\text{m/s}^2$ & $-9.243$ & $-0.564$ & $-9.807$ \\
$\omega_x$ & Gyro. & $0\,^{\circ}/\text{s}$ & $-2.55$ & $+2.53$ & $-0.02$ \\
$\omega_y$ & Gyro. & $0\,^{\circ}/\text{s}$ & $+2.45$ & $-2.68$ & $-0.23$ \\
$\omega_z$ & Gyro. & $0\,^{\circ}/\text{s}$ & $-2.91$ & $+2.44$ & $-0.47$ \\
\bottomrule
\end{tabular}
\end{table}

The gyroscope bias is particularly critical for the fall detection algorithm, as uncalibrated values would introduce a constant offset of approximately $4.6\,^{\circ}/\text{s}$ to the angular velocity magnitude calculation ($\omega = \sqrt{\omega_x^2 + \omega_y^2 + \omega_z^2}$). After calibration, the residual error is reduced to approximately $0.5\,^{\circ}/\text{s}$---negligible compared to the $240\,^{\circ}/\text{s}$ detection threshold. The calibration offsets are applied as ESPHome filter configurations, adding the offset value to each raw reading before further processing.

\clearpage
\subsection{ESP32 Environment Sensing Node}
\label{subsec:esp32}

The standard ESP32 node focuses on environmental monitoring and safety detection with local automation capabilities.

\begin{figure}[htbp]
    \centering
    \IfFileExists{images/ESP32.drawio.png}{%
        \includegraphics[width=0.9\linewidth,height=0.4\textheight,keepaspectratio]{images/ESP32.drawio.png}%
    }{%
        \fbox{\parbox{0.95\linewidth}{\centering
            Missing figure: \texttt{images/ESP32.drawio.png}
        }}%
    }
    \caption{ESP32 environment sensing node with labeled sensor components.}
    \label{fig:esp32-hardware}
\end{figure}

\begin{table}[htbp]
\centering
\caption{ESP32 Node Sensor Configuration}
\label{tab:esp32-sensors}
\begin{tabular}{llll}
\toprule
\textbf{Sensor} & \textbf{Model} & \textbf{Measurement} & \textbf{Interface} \\
\midrule
Color/Light & TCS34725 & RGB, Lux & I2C \\
Gas & MQ-2 & Smoke/Combustible gas & ADC \\
Motion & SR602 & PIR presence & GPIO \\
Indicator & RGB LED & Status feedback & PWM \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Power Supply Considerations.}
Unlike other sensors that operate on 3.3\,V logic levels, the MQ-2 gas sensor requires a dedicated 5\,V supply connected to the VIN pin. This requirement stems from the sensor's internal tin dioxide (SnO$_2$) heating element, which must maintain a specific operating temperature for accurate gas detection. According to the manufacturer datasheet, the heater voltage ($V_H$) must be $5.0\,\text{V} \pm 0.1\,\text{V}$, with a heater resistance of $29\,\Omega \pm 3\,\Omega$ and power consumption up to 950\,mW~\cite{mq2_datasheet_2014}. Supplying only 3.3\,V would result in insufficient heater temperature, causing unreliable gas concentration readings. The analog output (AO) pin, however, remains 3.3\,V tolerant and connects directly to the ESP32's ADC input (GPIO34).

Table~\ref{tab:esp32-pinout} details the complete GPIO assignments for the ESP32 environment sensing node.
\clearpage

\begin{table}[htbp]
\centering
\caption{ESP32 Node Pin Connections and Sensor Module Details}
\label{tab:esp32-pinout}
\resizebox{\linewidth}{!}{%
\begin{tabular}{lllll}
\toprule
\textbf{Module} & \textbf{Pin} & \textbf{ESP32 GPIO} & \textbf{Function} & \textbf{Notes} \\
\midrule
\multirow{6}{*}{TCS34725\footnotemark[4]} 
  & VIN & 3V3 & Power (2.7--3.6\,V) & --- \\
  & GND & GND & Ground & --- \\
  & SCL & GPIO32 & I2C Clock & Address 0x29 (fixed) \\
  & SDA & GPIO33 & I2C Data & --- \\
  & LED & GPIO25 & White LED control & Illumination for color sensing \\
  & INT & --- & Interrupt & --- \\
\midrule
\multirow{4}{*}{MQ-2\footnotemark[5]} 
  & VCC & VIN (5V) & Heater power & $V_H = 5.0\,\text{V} \pm 0.1\,\text{V}$ \\
  & GND & GND & Ground & --- \\
  & AO & GPIO34 & Analog output & 0--3.3\,V proportional to gas \\
  & DO & --- & Digital output & Threshold via comparator \\
\midrule
\multirow{3}{*}{SR602 PIR} 
  & VCC & 3V3 & Power (3.3--5\,V) & --- \\
  & GND & GND & Ground & --- \\
  & OUT & GPIO23 & Digital output & High on motion detection \\
\midrule
\multirow{4}{*}{RGB LED} 
  & R & GPIO26 & Red channel & LEDC PWM (8-bit) \\
  & G & GPIO27 & Green channel & LEDC PWM (8-bit) \\
  & B & GPIO14 & Blue channel & LEDC PWM (8-bit) \\
  & GND & GND & Ground & --- \\
\bottomrule
\end{tabular}%
}
\end{table}
\footnotetext[4]{\url{https://cdn-shop.adafruit.com/datasheets/TCS34725.pdf}}
\footnotetext[5]{\url{https://www.winsen-sensor.com/d/files/semiconductor/mq-2.pdf}}


The ESP32 node employs an identical mTLS configuration to the ESP32-S3 (Section~\ref{subsec:esp32s3}). As shown in Figure~\ref{fig:esp32-flowchart}, this node emphasizes on-device automation rather than edge analytics. The MQ-2 smoke sensor triggers threshold-based alerts at 5\,Hz sampling, while the SR602 PIR sensor operates in interrupt-driven mode. Both sensors directly control the RGB LED indicator without cloud dependency.

\clearpage
\begin{figure}[p]
    \centering
    \IfFileExists{images/ESP32_FC.png}{%
        \includegraphics[width=\linewidth,height=0.88\textheight,keepaspectratio]{images/ESP32_FC.png}%
    }{%
        \fbox{\parbox{0.95\linewidth}{\centering
            Missing figure: \texttt{images/ESP32_FC.png}
        }}%
    }
    \caption{ESP32 firmware execution flowchart: initialization with mTLS handshake, sensor acquisition, local automation rules for smoke detection and motion response, and MQTT state publishing. The complete firmware listing is provided in Appendix~\ref{app:esp32-config}.}
    \label{fig:esp32-flowchart}
\end{figure}
\clearpage

Local automation rules execute directly on the device: when the MQ-2 sensor voltage exceeds 2.5V, the RGB LED activates red pulsing effect and publishes an alert message to MQTT; SR602 motion detection triggers green LED illumination for visual feedback. Both nodes employ the dual-path communication design described in Section~\ref{sec:comm-arch}, with \texttt{discovery: true} enabling automatic entity registration in Home Assistant through the MQTT discovery protocol. The complete ESPHome configuration listings for both nodes, including TLS configuration and edge computing lambda expressions, are provided in Appendix~\ref{app:esphome}.

% ============================================================================
% 4.2 Software and Server Implementation
% ============================================================================
\section{Software and Server Implementation}
\label{sec:software}

The deployed system is operated as a hybrid-cloud infrastructure comprising four distinct nodes that span public cloud locations and a private home network. The nodes are interconnected using a Tailscale mesh VPN that implements a Zero Trust Network Access (ZTNA) model, enabling service exposure without assigning a public IP address to the local controller.

\subsection{Server Environment and Virtualization}
\label{subsec:server-env}

The hybrid-cloud infrastructure comprises four nodes spanning public cloud locations and a private home network (Table~\ref{tab:host-runtime}). The deployment demonstrates portability across heterogeneous hardware, including both x86\_64 and ARM64 architectures.

\begin{table}[htbp]
\centering
\caption{Deployment Host Runtime Summary}
\label{tab:host-runtime}
\resizebox{\linewidth}{!}{%
\begin{tabular}{lllll}
\toprule
\textbf{Node} & \textbf{Location} & \textbf{Role} & \textbf{OS / Kernel} & \textbf{Arch / Resources} \\
\midrule
NUE  & Nuremberg, DE & EMQX broker (Docker) & Debian 13 / 6.12.57 & x86\_64, 4 vCPU, 8 GB \\
FARM & Frankfurt, DE & SSL termination, bastion & Debian 12 / 6.1.0-41 & arm64, 4 vCPU, 24 GB \\
HKG  & Hong Kong, CN & Stress testing & Debian 12 / 6.1.0-39 & x86\_64, 2 vCPU, 2 GB \\
HAOS & Prague, CZ & Home Assistant (ESXi VM) & HAOS / 6.12.51-haos & x86\_64, 4 vCPU, 4 GB \\
\bottomrule
\end{tabular}%
}
\end{table}

Internet-facing nodes (NUE, FARM, HKG) enable BBR congestion control with FQ queueing to improve throughput stability~\cite{cardwell_bbr_2016}, while the local controller (HAOS) uses the default cubic/fq\_codel configuration. For large-scale experiments, open-file limits were raised to $10^6$ on public nodes, and TCP keepalive was set to 10\,s on HKG for rapid detection of broken connections.

\subsection{EMQX Broker Deployment}
\label{subsec:emqx}

EMQX\footnote{\url{https://www.emqx.io/}} was selected as the MQTT broker for its performance characteristics and native mTLS support~\cite{emqx_2024}. The broker is hosted on the NUE node, exposing a single Internet-facing endpoint on port 8883 with mutual TLS authentication. The management dashboard is bound to loopback and published through OpenResty reverse proxy.

The broker was deployed using Docker (Docker Compose) to ensure reproducible configuration across environments. In high-concurrency scenarios, the Linux per-process file descriptor limit inside the container can become a bottleneck (a common default is 1024). Therefore, the deployment explicitly increases the \texttt{nofile} limit via Compose \texttt{ulimits} (Appendix~\ref{app:emqx-docker}). This adjustment is required to support large numbers of simultaneous MQTT/TLS connections.

\subsection{Python Sensor Simulator}
\label{subsec:simulator}

The Python sensor simulator (\texttt{smarthome\_sim} package) provides virtual entity emulation for testing Home Assistant integration without physical hardware. Key features include configurable device counts, Home Assistant discovery payloads, mTLS connectivity, and multi-process execution. The simulator also supports load generation for scalability benchmarking as a secondary function, with results presented in Chapter~\ref{ch:evaluation}. Key code excerpts demonstrating the mTLS connection handling and entity simulation logic are provided in Appendix~\ref{app:simulator}. A sample terminal output showing the simulator in operation is presented in Appendix~\ref{app:simulator-terminal}.

Figure~\ref{fig:simulator-flowchart} illustrates the high-level workflow of the Python simulator, from configuration loading through entity publishing.

\begin{figure}[htbp]
\centering
\IfFileExists{images/py_chartflow.png}{%
    \includegraphics[width=0.80\linewidth]{images/py_chartflow.png}%
}{%
    \fbox{\parbox{0.85\linewidth}{\centering
        Missing figure: \texttt{images/py\_chartflow.png}
    }}%
}
\caption{Python sensor simulator workflow: configuration loading, mTLS connection establishment, Home Assistant discovery publishing, and event-driven simulation loop with heap-based scheduling.}
\label{fig:simulator-flowchart}
\end{figure}

ESPHome configurations are maintained as YAML files supporting custom logic through lambda expressions for edge computing calculations. The complete ESPHome configuration files for both sensor nodes are provided in Appendix~\ref{app:esphome}.
\clearpage
% ============================================================================
% 4.3 Home Assistant Integration
% ============================================================================
\section{Home Assistant Integration}
\label{sec:ha-integration}

Home Assistant's MQTT discovery feature enables automatic entity registration without manual configuration. Devices publish JSON payloads to designated discovery topics containing entity metadata, state topics, and device information. This mechanism reduces deployment friction and ensures consistent entity configuration across restarts. Home Assistant dashboards provide real-time visualization of sensor data and control interfaces, including sensor readings with historical graphs, device connectivity status, automation trigger history, and alert notifications.

\begin{figure}[htbp]
    \centering
    \IfFileExists{images/ha_dashboard.png}{%
        \includegraphics[width=0.95\linewidth]{images/ha_dashboard.png}%
    }{%
        \fbox{\parbox{0.95\linewidth}{\centering
            Missing figure: \texttt{images/ha\_dashboard.png}
        }}%
    }
    \caption{Home Assistant dashboard displaying real-time sensor data and device controls.}
    \label{fig:ha-dashboard}
\end{figure}

\clearpage
% ============================================================================
% 4.4 Data Pipeline and Automation
% ============================================================================
\section{Data Pipeline and Automation}
\label{sec:data-pipeline}

InfluxDB\footnote{\url{https://www.influxdata.com/}} serves as the time-series database for long-term sensor data retention~\cite{influxdb_2024}. Home Assistant's native integration automatically writes entity state changes, enabling historical analysis, trend detection, and anomaly identification. Figure~\ref{fig:influxdb-query} demonstrates a query result showing one hour of G-force measurements from the ESP32-S3 fall detection sensor, with data points aggregated at regular intervals. Grafana\footnote{\url{https://grafana.com/}} connects to InfluxDB as a data source, providing advanced visualization capabilities including multi-sensor overlay comparisons, statistical aggregations, threshold-based alerting, and custom time range analysis (Figure~\ref{fig:grafana-sensors}).

\begin{figure}[H]
    \centering
    \setlength{\abovecaptionskip}{2pt}
    \setlength{\belowcaptionskip}{0pt}
    \IfFileExists{images/influxdb.png}{%
        \includegraphics[width=0.85\linewidth]{images/influxdb.png}%
    }{%
        \fbox{\parbox{0.85\linewidth}{\centering
            Missing figure: \texttt{images/influxdb.png}
        }}%
    }
    \caption{InfluxDB query result showing G-force sensor data over a one-hour period, demonstrating time-series data retention for historical analysis.}
    \label{fig:influxdb-query}
\end{figure}

\begin{figure}[H]
    \centering
    \setlength{\abovecaptionskip}{2pt}
    \setlength{\belowcaptionskip}{0pt}
    \IfFileExists{images/grafana.png}{%
        \includegraphics[width=0.85\linewidth]{images/grafana.png}%
    }{%
        \fbox{\parbox{0.85\linewidth}{\centering
            Missing figure: \texttt{images/grafana.png}
        }}%
    }
    \caption{Grafana dashboard displaying real-time sensor data: barometric pressure (hPa), G-force magnitude, and MQ-2 smoke sensor analog voltage (V).}
    \label{fig:grafana-sensors}
\end{figure}

Native Home Assistant automations handle event-driven responses using YAML configuration, demonstrating integration between hardware sensors and mobile notifications. Node-RED\footnote{\url{https://nodered.org/}} provides visual flow-based programming for complex automation scenarios requiring multi-branch conditional logic, data transformation, or external API integration. Figure~\ref{fig:nodered-flow} illustrates the fall detection notification flow implemented in Node-RED.

\begin{figure}[H]
    \centering
    \setlength{\abovecaptionskip}{2pt}
    \setlength{\belowcaptionskip}{0pt}
    \IfFileExists{images/node-red.png}{%
        \includegraphics[width=0.9\linewidth]{images/node-red.png}%
    }{%
        \fbox{\parbox{0.9\linewidth}{\centering
            Missing figure: \texttt{images/node-red.png}
        }}%
    }
    \caption{Node-RED flow for fall detection notification: sensor state triggers iOS push notification and persistent HA alert.}
    \label{fig:nodered-flow}
\end{figure}
% \clearpage
Figure~\ref{fig:fall-detection-demo} demonstrates the complete fall detection pipeline in operation. The ESP32-S3 node continuously computes the Signal Magnitude Vector (SMV) from three-axis accelerometer data and the angular velocity magnitude from three-axis gyroscope data. When both computed values exceed their respective thresholds ($\text{SMV} > 2.4\,\text{G}$ and $\omega > 240\,^{\circ}/\text{s}$), the binary sensor state transitions to \texttt{unsafe}, triggering the Node-RED automation to deliver notifications via iOS push and Home Assistant persistent notification.

\begin{figure}[H]
    \centering
    \setlength{\abovecaptionskip}{2pt}
    \setlength{\belowcaptionskip}{0pt}
    \IfFileExists{images/red.png}{%
        \includegraphics[width=0.77\linewidth]{images/red.png}%
    }{%
        \fbox{\parbox{0.77\linewidth}{\centering
            Missing figure: \texttt{images/red.png}
        }}%
    }
    \caption{Fall detection demonstration: (P1)~sensor data computation on ESP32-S3 dashboard, (P2)~iOS critical notification, and (P3)~Home Assistant persistent alert.}
    \label{fig:fall-detection-demo}
\end{figure}

% \clearpage
\subsection{Backup Strategy}
\label{subsec:backup}

Home Assistant provides built-in backup functionality supporting both local and cloud storage destinations. The deployed system implements a two-tier backup strategy: local backups are created every three days with 14 retained copies (covering approximately six weeks of recovery points), while cloud backups to Google Drive are performed daily with 30-day retention. This configuration ensures rapid recovery from local storage for recent issues while maintaining off-site protection against hardware failures or local disasters.

\begin{figure}[htbp]
    \centering
    \IfFileExists{images/backup_SET.png}{%
        \includegraphics[width=0.9\linewidth]{images/backup_SET.png}%
    }{%
        \fbox{\parbox{0.9\linewidth}{\centering
            Missing figure: \texttt{images/backup\_SET.png}
        }}%
    }
    \caption{Home Assistant backup configuration interface showing local and cloud backup schedules.}
    \label{fig:backup-config}
\end{figure}

While this approach does not constitute a full 3-2-1 backup strategy (three copies, two media types, one off-site), it provides practical data protection appropriate for a demonstration deployment. The combination of local and cloud storage destinations addresses the most common failure scenarios: accidental configuration changes can be recovered from local backups within seconds, while storage device failures are protected by cloud redundancy.


